COMMENT
    Sergey: stimulation with a train of stimuli is embedded into this gap junction
ENDCOMMENT

NEURON {
    POINT_PROCESS GapCaSt
    NONSPECIFIC_CURRENT icagap
    USEION ca READ cai WRITE ica
    RANGE r, icagap, ica, tau1, tau2, ECa
    RANGE seed : Added by Sergey
}

UNITS {
    (molar) = (1/liter)
    (mM) =    (millimolar)
    (um) =    (micron)
    (mA) =    (milliamp)
    FARADAY = (faraday) (10000 coulomb)
    PI =      (pi)      (1)
    (uS) =    (microsiemens)
}

PARAMETER {
    r = 100000        (megohm)
    ECa = 0.00006     (mM)
    tau1 = 100        (ms) <1e-9,1e9>
    tau2 = 1000       (ms) <1e-9,1e9>
    : The following parameters were added by Sergey
    weight = 4        (1)   : "stim" variable from the original version of axon_collat.hoc
    reqNumImp = 5     (1)   : The required number of impulses ("NumberStim" from the original version of axon_collat.hoc)
    meanInterval = 50 (ms)  : Mean interval between impulses ("Interval" from the original version of axon_collat.hoc)
    seed = 0          (1)   : Random number generator seed
}

ASSIGNED {
    cai    (mM)

    icagap (nanoamp)
    ica    (nanoamp) : so you can plot the calcium current generated by this mechanism
    factor
    total
    
    diam   (um)      : Added by Sergey to avoid compile-time message "Warning: diam undefined. (declared within VERBATIM?)"
}

STATE {
    ACa
    BCa
    : The following states were added by Sergey
    timePrev
    actNumImp
    delay
}

INITIAL {
    LOCAL tp
    total = 0
    if (tau1/tau2 > .9999) {
        tau1 = .9999*tau2
    }
    ACa = 0
    BCa = 0
    tp = (tau1*tau2)/(tau2 - tau1) * log(tau2/tau1)
    factor = -exp(-tp/tau1) + exp(-tp/tau2)
    factor = 1/factor
    
    : Initialization of the state variables added by Sergey
    timePrev = 0
    actNumImp = 0
    VERBATIM
        double lambda = 1 / meanInterval;   // The parameter of negative exponential distribution
        
        // Make sure that different processes use different seeds
        srand((int)seed);
        // printf("seed = %g\n", seed);
        
        // Choose delay for the next impulse
        double rn = rand() / ((double)RAND_MAX + 1);    // Get a random number in range [0, 1)
        delay = -log(1 - rn) / lambda;                  // Get delay of the next impulse with negative exponential distribution inverse CDF
        // printf("delay = %g\n", delay);
    ENDVERBATIM
}

BREAKPOINT {

    LOCAL vImpulse
    
    : "vImpulse" -- a binary variable assigned in the VERBATIM block below.
    : 1.0 -- an impulse will be generated on this iteration,
    : 0.0 -- no impulse will be generated.

    VERBATIM
        double lambda = 1 / meanInterval;   // The parameter of negative exponential distribution
        
        if (actNumImp < reqNumImp)
        {
            // Verify if an impulse will be generated on this iteration
            if (delay <= 0)
            {
                // It's time to generate an impulse
                _lvImpulse = 1;
                actNumImp++;
                // printf("impulse at t = %g\n", t);
                
                // Choose delay for the next impulse
                double rn = rand() / ((double)RAND_MAX + 1);    // Get a random number in range [0, 1)
                delay = -log(1 - rn) / lambda;                  // Get delay of the next impulse with negative exponential distribution inverse CDF
                
                if (actNumImp < reqNumImp)
                {
                    // printf("delay = %g\n", delay);
                }
            }
            else
            {
                // No impulse will be generated on this iteration
                _lvImpulse = 0;
                
                delay -= (t - timePrev);
            }
            
            timePrev = t;
        }
    ENDVERBATIM

    if (vImpulse) {
        : state_discontinuity(ACa, ACa + weight*factor)
        : state_discontinuity(BCa, BCa + weight*factor)
        ACa = ACa + weight*factor
        BCa = BCa + weight*factor
        total = total+weight
    }
    
    SOLVE state METHOD cnexp
    ica = (BCa-ACa)*(cai - ECa)*(2*FARADAY)/(PI*diam)/r
}

DERIVATIVE state {
    ACa' = -ACa/tau1
    BCa' = -BCa/tau2
}